" vim: ft=vim:fdm=marker:fen:
" ䷀ ䷁ ䷂ ䷃ ䷄ ䷅ ䷆ ䷇ ䷈ ䷉ ䷊ ䷋ ䷌ ䷍ ䷎ ䷏ ䷐ ䷑ ䷒ ䷓ ䷔ ䷕ ䷖ ䷗ ䷘ ䷙ ䷚ ䷛ ䷜ ䷝ ䷞ ䷟ •
" •
" ䷣   ——Vaz•縷々
" •
" ䷠ ䷡ ䷢ ䷣ ䷤ ䷥ ䷦ ䷧ ䷨ ䷩ ䷪ ䷫ ䷬ ䷭ ䷮ ䷯ ䷰ ䷱ ䷲ ䷳ ䷴ ䷵ ䷶ ䷷ ䷸ ䷹ ䷺ ䷻ ䷼ ䷽ ䷾ ䷿ •
"
" TODO:{{{1
" - fix completion
" - fix auto-indent/auto-bullet list
" - make K do something useful (look up something...)
" - spell check when it makes sense

" :: Settings {{{1
" :::: general {{{2
set nocompatible                  " thanks for everything, vi
set backup                        " keep backup after writing
set writebackup                   " use backup when writing a file
set backupdir=~/.vim/tmp/backup,.
set dir=~/.vim/tmp/swap,.         " swap file locations
set history=500                   " remember 500 ex commands
set clipboard+=unnamed            " unnamed register = os clipboard
set viminfo='20,h                 " remember marks in 'files, not hlsearch
set viminfo+=<50,s10              " remember registers: <Lines sSize-in-Kb
set viminfo+=%                    " remember buflist if invoked w/o args
set cryptmethod=blowfish          " use actually secure crypto with :X
set switchbuf=useopen             " switch to existing buffer in another window

" :::: control {{{2
set mouse=a                       " enable mouse (scrolling is nice)
set backspace=indent,eol,start    " <bs> over stuff like a normal editor
set virtualedit=onemore,block     " move one past eol, anywhere in ^V

" :::: formatting {{{2
set expandtab                     " expand tabs into spaces
set tabstop=8                     " hard tab indent size
set softtabstop=2                 " virtual indent size for tab and backspace and some other stuff
set shiftwidth=2
set textwidth=78        " text width below 80
set formatoptions=croql " but don't automatically word wrap

" :::: search {{{2
set incsearch           " do incremental searching
set ignorecase          " ignore case when searching in all lower-case
set smartcase           " but not when searching with some caps
set nohlsearch          " don't highlight search results by default

" :::: interface {{{2
silent! set beval bdlay=300     " enable popup balloons
set showcmd             " display incomplete normal mode commands
set shortmess+=I        " skip splash screen on empty files
set ruler
set scrolloff=3         " keep n lines ahead or behind always showing
set hidden              " buffers can be hidden while modified
set splitright splitbelow " split more intuitively
set diffopt+=vertical   " always vertical split when :diffsplit
set cursorline cursorcolumn
silent! set colorcolumn=80 " so I know 80
set laststatus=2        " always show status lines
set list                " show control characters, line endings etc.
silent! set listchars=tab:→\ ,trail:␣,extends:…,precedes:…,nbsp:·,eol:¬
silent! set showbreak=↪
if version >= 703 | set rnu | else | set nu | endif
set noerrorbells visualbell
set t_vb="\<Esc>]Plffbbbb\<Esc>\\"
silent! set conceallevel=2 " conceal shows replacements
silent! set concealcursor=nc " and always conceal in normal mode and search
set dict+=/usr/share/dict/words
" could use yubnub to get live values for thesaurus and dictionary maybe
set completeopt=menuone,longest,preview
set foldenable foldlevel=1000 foldmethod=marker
set display=lastline  " show as much as possible from last (long) line
set ttimeoutlen=500   " shorter timeout for keycodes (like esc)
set ttyscroll=500     " just redraw if there's that much to scroll
if !empty($SSH_CONNECTION)
  set ttyscroll=10
endif

set wildmode=longest,list " tab autocomplete like bash

set wildignore+=*.orig,*.rej,*~,#*#,.*.s[a-w][a-z],.DS_Store,._*,.Trash
set wildignore+=*.py[co],*.o,*.so,*.so.*,*.dll,*.a,*.dylib,*.exe,*.bin,*.out

" :: Keymappings and commands ::{{{1

" :::: general {{{2

" set mapleader
let mapleader="\\"
let g:mapleader="\\"

" local cd to current file's dir
nnoremap <leader>c :lcd %:p:h<cr>

nnoremap Q q:

" }}}
" :::: movement {{{2

" swap ` for ' because ' is closer and ` is more useful.
noremap ' `

" navigate changelist with _ and +, jumplist with - and =
" map g= to = to free up =
noremap g= =
noremap _ g;
noremap + g,
noremap - <c-o>
noremap = <c-i>

" make up and down keys useful
"noremap <up> <c-u>
"noremap <down> <c-d>
"noremap <left> ^
"noremap <right> $
nnoremap <space>h ^
nnoremap <space>l $l

" make repeating f/t commands ignore linebreaks

" noremap  f @=FfTt( 1, 0)<cr>
" noremap  <expr> F FfTt(-1, 0)
" noremap  <expr> t FfTt( 1, 1)
" noremap  <expr> T FfTt(-1, 1)
" onoremap <expr> f FfTt( 1, 0, 1)
" onoremap <expr> F FfTt(-1, 0, 1)
" onoremap <expr> t FfTt( 1, 1, 1)
" onoremap <expr> T FfTt(-1, 1, 1)

" noremap  <expr> ; FfTtAgain()
" noremap  <expr> , FfTtAgain(1)
" onoremap <expr> ; FfTtAgain(0, 1)
" onoremap <expr> , FfTtAgain(1, 1)

" command! -count=N FfTt :

" char is the character to search for
" dir should be 1 (forward, like f/t) or -1 (backward, like F/T)
" excl should be 0 (inclusive, like f/F) or 1 (exclusive, like t/T)
function! s:FfTtSearch(char, dir, excl, omap)
  let [l:line, l:col] = searchpos(a:char, (a:dir>0?'':'b'))
  let l:col = l:col + a:omap - (a:dir * a:excl)
  return ":call cursor(".l:line.", ".l:col.")\<cr>"
endfunction

function! FfTt(...)
  let l:char = nr2char(getchar())
  let l:dir  = a:0 >= 1 ? a:1 : (exists(s:fftt_ldir)  ? s:fftt_ldir  : 1)
  let l:excl = a:0 >= 2 ? a:2 : (exists(s:fftt_lexcl) ? s:fftt_lexcl : 0)
  let l:omap = a:0 >= 3 ? a:3 : 0
  let [s:fftt_lchar, s:fftt_ldir, s:fftt_lexcl] = [l:char, l:dir, l:excl]
  return s:FfTtSearch(l:char, l:dir, l:excl, l:omap)
endfunction

function! FfTtAgain(...)
  if exists(s:fftt_lchar)
    let l:dir  = a:0 >= 1 ? a:1 : s:fftt_ldir
    let l:omap = a:0 >= 2 ? a:2 : 0
    return s:FfTtSearch(s:fftt_lchar, l:dir, s:fftt_lexcl, l:omap)
  endif
endfunction


" scroll viewport faster
nnoremap <c-e> 5<c-e>
nnoremap <c-y> 5<c-y>

" apple HIG style movements
" map meta + arrows in terminal

no   <D-Left>       <Home>
no!  <D-Left>       <Home>
no   <M-Left>       <C-Left>
no!  <M-Left>       <C-Left>

no   <D-Right>      <End>
no!  <D-Right>      <End>
no   <M-Right>      <C-Right>
no!  <M-Right>      <C-Right>

no   <D-Up>         <C-Home>
ino  <D-Up>         <C-Home>
no   <m-up>         {
imap <M-Up>         <C-o>{

no   <D-Down>       <C-End>
ino  <D-Down>       <C-End>
no   <m-down>       }
imap <M-Down>       <C-o>}

imap <M-BS>         <C-w>
inoremap <D-BS>     <esc>ld0i

" }}}
" :::: editing {{{2

" make R in visual mode do what I would expect it to
vnoremap R r R

" pressing return in normal mode opens a line above
" hijacking the key for ctrlp
" nnoremap <cr> mOO<esc>`O
" pressing shift-return in normal mode opens line below
" this only works in gui vim
" nnoremap <s-cr> mOo<esc>`O

" easy underlining/overlining
nnoremap <leader>uo= yyPVr=jyypVr=
nnoremap <leader>uo* yyPVr*jyypVr*
nnoremap <leader>u=  yypVr=
nnoremap <leader>u-  yypVr-

" dragging lines
nnoremap <silent> ∆ :m+<cr>
nnoremap <silent> ˚ :m-2<cr>
vnoremap ∆ :m'>+<cr>gv
vnoremap ˚ :m-2<cr>gv

" }}}
" :::: search {{{2

" good regexes in search, clear old highlighting
noremap <silent> / :set hls<cr>/
ounmap /

" turn on search highlighting for n/n and */#
noremap <silent> n nzv:set hls<cr>
noremap <silent> N Nzv:set hls<cr>
ounmap n
ounmap N
noremap <silent> * *zv:set hls<cr>
noremap <silent> # #zv:set hls<cr>
ounmap *
ounmap #

" }}}
" :::: diff {{{2

nnoremap <leader>du :diffupdate<cr>
nnoremap <leader>dt :diffthis<cr>
nnoremap <leader>do :diffoff<cr>
nnoremap <leader>do :diffoff!<cr>
nnoremap <leader>ds :vert diffsplit<cr>

" }}}
" :::: spelling {{{
command! English set spell spelllang=en
command! French set spell spelllang=fr
" }}}
" :::: GPG encryption {{{2

function! WriteGPGEncrypted(fn)
  if !len(a:fn)
    let l:fn=expand("%")
    if !(l:fn =~ '\.\(gpg\|asc\|pgp\)$')
      let l:fn=l:fn . '.gpg'
    endif
  else
    let l:fn=expand(a:fn)
  endif
  let l:fn=escape(l:fn, '#%\[]')
  exe "w !gpg -ae -o '" . l:fn . "'"
endfunction

command! -nargs=? WriteGPGEncrypted call WriteGPGEncrypted("<args>")

" }}}
" :::: registers {{{2

" make Y work like D, C, ...
noremap Y y$

" paste with blackhole register to preserve current register contents
nnoremap <silent> <leader>p "_p
nnoremap <silent> <leader>P "_P

" }}}
" :::: windows {{{2

" make window movement a lot easier
noremap q <c-w>
" don't like accidently quitting windows with qq
noremap qq <c-w><c-w>
" relegate recording to leader mapping
noremap <leader>q q


function! MaximizeToggle()
  if exists("s:maximize_session")
    exec "source " . s:maximize_session
    call delete(s:maximize_session)
    unlet s:maximize_session
    let &hidden=s:maximize_hidden_save
    unlet s:maximize_hidden_save
  else
    let s:maximize_hidden_save = &hidden
    let s:maximize_session = tempname()
    set hidden
    exec "mksession! " . s:maximize_session
    only
  endif
endfunction
nnoremap <silent> <leader>w :call MaximizeToggle ()<CR>

" }}}
" :::: display {{{2

" toggle showing control characters
nnoremap <silent> <leader>L :set list!<cr>

function! NumberToggle()
  if(&number == 1)
    if version >= 703
      set rnu
    else
      set nonu
    endif
  elseif(&relativenumber == 1)
    set nornu
  else
    set nu
  endif
endfunc

" toggle showing relative line numbers
nnoremap <silent> <leader>n :call NumberToggle()<cr>

" switch tabbing style
nnoremap <leader>2 <esc>:set expandtab tabstop=2 softtabstop=2 shiftwidth=2<cr>
nnoremap <leader>4 <esc>:set expandtab tabstop=4 softtabstop=4 shiftwidth=4<cr>
nnoremap <leader>8 <esc>:set expandtab tabstop=8 softtabstop=8 shiftwidth=8<cr>
nnoremap <leader><leader>2 <esc>:set noexpandtab tabstop=2 softtabstop=2 shiftwidth=2<cr>
nnoremap <leader><leader>4 <esc>:set noexpandtab tabstop=4 softtabstop=4 shiftwidth=4<cr>
nnoremap <leader><leader>8 <esc>:set noexpandtab tabstop=8 softtabstop=8 shiftwidth=8<cr>

" }}}
" :::: text objects {{{2

onoremap ir i[
onoremap ar a[
vnoremap ir i[
vnoremap ar a[

" :::: introspection {{{2

" show syntax highlighting groups for word under cursor
nnoremap <silent> <leader>h :call <SID>SynStack()<CR>
function! <SID>SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

" }}}
" :::: buffers {{{2

" easier switching buffers, opening files
nnoremap <silent> H :bp<cr>
nnoremap <silent> L :bn<cr>
nnoremap <silent> <backspace> :bd<cr>
nnoremap <silent> <leader><backspace> :BD<cr>

function! FlipIfListed()
  if buflisted(bufnr("#")) | exe "normal! \<c-^>" | endif
endfunction
nnoremap <silent> ` :call FlipIfListed()<cr>

" }}}
" :::: vim config file shortcuts {{{2

" quick edit files
nnoremap <leader>ev <esc>:e ~/.vimrc<cr>
nnoremap <leader>eg <esc>:e ~/.gvimrc<cr>
nnoremap <leader>ec <esc>:exec "e ".<sid>ColourFile()<cr>

nnoremap <leader>.v <esc>:so ~/.vimrc<cr>
nnoremap <leader>.g <esc>:so ~/.gvimrc<cr>
nnoremap <leader>.c <esc>:exec "so ".<sid>ColourFile()<cr>

fun! s:ColourFile()
  if exists('g:colors_name')
    for p in split(&runtimepath, ',')
      let f = p."/colors/".g:colors_name.".vim"
      if filereadable(f) | return f | endif
    endfor
  endif
endf


" }}}
" :::: timestamps {{{2

" insert timestamps
iab <expr> ~~t strftime("%H:%M:%S")
iab <expr> ~~d strftime("%y年%m月%d日")
iab <expr> ~~D strftime("%y/%m/%d/")
iab <expr> ~~s strftime("%y年%m月%d日 %H:%M:%S")
iab <expr> ~~S strftime("%y/%m/%d/ %H:%M:%S")
iab <expr> ~~l strftime("%a %d %b %Y")
iab <expr> ~~z strftime("%a %d %b %Y %H:%M:%S")
iab <expr> ~~L strftime("%A %d %B %Y")
iab <expr> ~~Z strftime("%A %d %B %Y %H:%M:%S")


" }}}
" :::: visual mode {{{2

" select last put text
nnoremap <expr> gl '`[' . strpart(getregtype(), 0, 1) . '`]'

" }}}
" :::: opening and saving {{{2

" Command for opening a url on a mac:
command! -bar -nargs=1 OpenURL :!open <args>

" sudo save a file
cnoremap w!! w !sudo tee % >/dev/null

" open in Marked
nnoremap <leader>m :silent !open -a Marked.app '%:p'<cr>

" }}}

" :: Plugins ::{{{1

" Vundle
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

" Let Vundle manage Vundle!
Bundle 'gmarik/vundle'

Bundle 'tpope/vim-surround'
Bundle 'tpope/vim-repeat'
Bundle 'tpope/vim-abolish'
Bundle 'tpope/vim-commentary'
  " autocmd FileType whatever set commentstring=#\ %s
Bundle 'vim-scripts/TailMinusF'
Bundle 'Lokaltog/vim-easymotion'
  let g:EasyMotion_leader_key = '<space>'
Bundle 'nathanaelkane/vim-indent-guides'
  let g:indent_guides_auto_colors = 0
  let g:indent_guides_enable_on_vim_startup = 1
Bundle 'vimoutliner/vimoutliner'
Bundle 'scrooloose/nerdtree'
  nnoremap <leader>t :NERDTreeToggle<cr>
" Bundle 'ervandew/supertab'
"   let g:SuperTabDefaultCompletionType = "context"
"   let g:SuperTabContextDefaultCompletionType = "<c-n>"
"   let g:SuperTabCompletionContexts = ['s:ContextText', 's:ContextDiscover']
"   let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&keywordfunc', '&completefunc']
"   let g:SuperTabDefaultCompletionTypeDiscovery = ["&completefunc:<c-x><c-u>", "&omnifunc:<c-x><c-o>", '&keywordfunc:<c-n>']
"   let g:SuperTabRetainCompletionDuration = 'completion'
"   let g:SuperTabLongestEnhanced = 1
"   augroup supertab
"     au FileType css let g:SuperTabDefaultCompletionType = '<c-x><c-o>'
"   augroup END
Bundle 'altercation/vim-colors-solarized'
  let g:solarized_termcolors=256
  let g:solarized_hitrail=1    "default value is 0
" Bundle 'git://git.wincent.com/command-t.git'
"   nnoremap <silent> <leader><space> :CommandT<cr>
"   let g:CommandTMaxFiles = 50000
"   let g:CommandTMaxHeight = 20
"   let g:CommandTMinHeight = 20
"   let g:CommandTMatchWindowReverse = 1
"   let g:CommandTCancelMap = ['<C-c>', '<esc>']
Bundle 'sjbach/lusty'
  nnoremap <silent> <tab> :LustyJuggler<cr>
  nnoremap <silent> <s-tab> :LustyBufferExplorer<cr>
  nnoremap <silent> <leader>o :LustyFilesystemExplorer<cr>
  nnoremap <silent> <leader>O :LustyFilesystemExplorerFromHere<cr>
  let g:LustyJugglerSuppressRubyWarning = 1
Bundle 'ack.vim'
Bundle 'rstacruz/sparkup', {'rtp': 'vim/'}
  augroup sparkup_types
    autocmd!
    autocmd FileType mustache,php,htmldjango runtime! ftplugin/html/sparkup.vim
    let g:sparkupExecuteMapping = '<c-l>'
  augroup END
Bundle 'tpope/vim-rails.git'
Bundle 'tpope/vim-fugitive'
Bundle 'groenewege/vim-less'
Bundle 'timcharper/textile.vim'
Bundle 'scrooloose/syntastic'
  nnoremap <leader>s :SyntasticToggleMode<cr>
Bundle 'mattn/calendar-vim'
Bundle 'chrisbra/NrrwRgn'
Bundle 'vim-scripts/utl.vim'
Bundle 'hsitz/VimOrganizer'
Bundle 'tomasr/molokai'
Bundle 'trapd00r/vim-syntax-vidir-ls'
Bundle 'kchmck/vim-coffee-script'
Bundle 'vim-scripts/matchit.zip'
Bundle 'vim-scripts/ruby-matchit'
Bundle 'jamessan/vim-gnupg'
  let s:GPGext='\(gpg\|asc\|pgp\)'
  let g:GPGFilenamePattern='*#'.s:GPGext.'*,*.'.s:GPGext.'.txt,*.'.s:GPGext
  let g:GPGPreferArmor=1
Bundle 'jcf/vim-latex'
  augroup latexsuite
    au!
    au FileType tex set sw=2 iskeyword+=:
  augroup END
  set grepprg=grep\ -nH\ $*
  let g:tex_flavor='latex'
Bundle 'matthias-guenther/hammer.vim'
Bundle 'vaz/vim-gitgutter'
Bundle 'Lokaltog/vim-powerline'
  let g:Powerline_symbols = 'fancy'
  let g:Powerline_stl_path_style = 'short'
  set noshowmode
Bundle 'godlygeek/tabular'
  noremap <silent> <leader>a= :Tabularize /=<cr>
  noremap <silent> <leader>a: :Tabularize /:\zs<cr>
  noremap <silent> <leader>aw :Tabularize /\w\+<cr>
  noremap <silent> <leader>aW :Tabularize /\S\+<cr>
  noremap <silent> <leader>a1 :Tabularize /^\s*\S\+\zs<cr>
  noremap <silent> <leader>a2 :Tabularize /^\s*\(\S\+\s*\)\{2\}\zs<cr>
  noremap <silent> <leader>a3 :Tabularize /^\s*\(\S\+\s*\)\{3\}\zs<cr>

  " from https://gist.github.com/tpope/287147
  inoremap <silent> <Bar> <Bar><Esc>:call <SID>align_table()<CR>a

  function! s:align_table()
    let p = '^\s*|\s.*\s|\s*$'
    if exists(':Tabularize') && getline('.') =~# '^\s*|' &&
          \ (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
      let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
      let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
      Tabularize/|/l1
      normal! 0
      call search(repeat('[^|]*|',column).'\s\{-\}'.
            \ repeat('.',position),'ce',line('.'))
    endif
  endfunction

  "inoremap <silent> <s-tab> <esc>:call <sid>live_align()<cr>a
  "function!  s:live_align()
  "  " grab the WORD we're on or just after
  "  normal! mTlB"TyE
  "
  "  let target = getreg('T')
  "
  "
  "endfunction
Bundle 'Valloric/YouCompleteMe'
Bundle 'derekwyatt/vim-scala'
Bundle 'sophacles/vim-bundle-mako'
Bundle 'kien/ctrlp.vim'
  let g:ctrlp_map = '<cr>'
  let g:ctrlp_match_window_bottom = 1
  let g:ctrlp_max_height = 30
  " if file is already open in a window somewhere, just switch to it:
  let g:ctrlp_switch_buffer = 'E'
  " 'r': repo root; that is, nearest ancestor with a .git, .hg, .svn, ...
  " otherwise:
  " 'a': %:h unless % is in a dir below vim's cwd
  " 'w': modifies 'r' to start looking from vim's actual cwd instead of %:h
  let g:ctrlp_working_path_mode = 'ra'
  " show dotfiles/dotdirs?  would be nice to be able to toggle this easily
  let g:ctrlp_show_hidden = 0
  let g:ctrlp_max_files = 5000
  let g:ctrlp_follow_symlinks = 1
  " let g:ctrlp_custom_ignore = {




"set wildignore=.git,.hg,.svn,.cvs,.bazaar
"set wildignore+=*.zip,*.tar,*.tar,*.rar,*.7z,*.gz,*.bzip,*.bz2,*.iso,*.dmg
"set wildignore+=*.class,*.[jwe]ar,*.apk,*.ap_,
"set wildignore+=node_modules
"set wildignore+=.rbenv-version,.bundle,*.gem
"set wildignore+=*.egg-info,.Python,.ipython,.pip,.python-eggs,*.egg
"set wildignore+=*.mo,*.rpm,*.deb,*.xpi
Bundle 'chrisbra/Recover.vim'
Bundle 'digitaltoad/vim-jade'
Bundle 'tpope/vim-git'
Bundle 'vim-scripts/bufkill.vim'
Bundle 'mhinz/vim-startify'
" ::bundle tail::
"

command! -nargs=1 -bar BundleGet call BundleGet(<f-args>)
function! BundleGet(bundle)
  edit ~/.vimrc
  0/^\" ::bundle tail::$/ s/^/\=printf("Bundle '%s'", a:bundle)
  BundleInstall
  close
  write
endfunction

command! -nargs=1 -bar BundleConfig call BundleConfig(<f-args>)
function! BundleConfig(bundle)
  edit ~/.vimrc
  exe "0/^Bundle '.*".a:bundle.".*'$"
endfunction


" :: Syntax, colours and terminal-specific stuff ::"{{{1

if &term =~ "256color"
  set t_Co=256
endif

" Change cursor shape in insert mode
if $TERM_PROGRAM =~? "iterm"
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif


if &t_Co > 2 
  syntax on
  colorscheme molokai
  let g:colors_loaded = 1
  hi Normal ctermbg=none
  hi CursorLine guibg=#232526
  hi CursorColumn guibg=#232526
  hi Folded guifg=#bb88bb guibg=#000000
  hi Search ctermfg=253 ctermbg=233
  hi DiffText cterm=bold ctermbg=17 guibg=#4C2755 gui=bold,italic
  hi DiffChange ctermfg=181 ctermbg=18 guifg=#89807D guibg=#2C1735
endif

"
" :: Autocommands ::{{{1

" Enable file type detection.
filetype plugin indent on

" Put these in an autocmd group, so that we can delete them easily.
augroup vimrc
  au!

  " text formatting:
  " set nolist showbreak= linebreak

  au FileType text set nolist showbreak= linebreak commentstring=%s

  " absolute line numbers in insert mode
  au InsertEnter * :set nu
  au InsertLeave * :set rnu

  " Leave insert mode when idling
  " au CursorHoldI * stopinsert   " nope this is pretty annoying.

  " Turn off search highlighting when moving
  "au CursorMoved,InsertEnter * set nohls

  " when editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  au BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

  " resize splits when window is resized
  au VimResized * :wincmd =

  au BufNewFile,BufRead * if &syntax == '' | set foldmethod=indent | endif

  " don't expand tabs to spaces in makefiles
  au FileType make setlocal noexpandtab

  au FileType ruby nnoremap <leader>r <esc>:!ruby %<cr>

  au FileType python nnoremap <leader>P <esc>:call Pep8()<cr> |
                   \ nnoremap <leader>r <esc>:!python %<cr>


  au FileType php set expandtab tabstop=8 softtabstop=2 shiftwidth=2

  " A mapping to source vim files
  " And a mapping to start automatically sourcing the current vim file
  " every time it saves (Good for editing colour files)
  au FileType vim
        \ nnoremap <leader>. <esc>:so %<cr>|
        \ nnoremap <leader>S <esc>:au BufWritePost <buffer> :so %<cr>

  " don't always center the cursor in screen when switching buffers
  au BufLeave * let b:winview = winsaveview()
  au BufEnter * if(exists('b:winview')) | call winrestview(b:winview) | endif

  " conceal to prettify
  au VimEnter * syntax keyword Statement lambda conceal cchar=λ
  au VimEnter * syntax match Operator "->" conceal cchar=→
  au VimEnter * syntax match Operator "=>" conceal cchar=➧
  au FileType haskell,lhaskell syntax match Operator "<-" conceal cchar=←
  au FileType haskell,lhaskell syntax match Operator "-<" conceal cchar=⤛
  au VimEnter * hi! link Conceal Statement

  au FileType help nnoremap <silent> <buffer> <cr> <c-]>

  " always show where we are, foldwise
  au BufReadPost * normal! zv

  " better cursors when wrapping
  au FileType * if &wrap |
        \ map <buffer> <up>     gk |
        \ map <buffer> <down>   gj |
        \ map <buffer> <right>  gl |
        \ map <buffer> <left>   gh

  "au FileType '' set filetype=text
augroup END

augroup lines
  au!
  au WinLeave,InsertEnter * set nocursorline | set nocursorcolumn
  au WinEnter,InsertLeave * set cursorline | set cursorcolumn
augroup END

augroup reloadvimrc
  au!
  " reload vimrc when we save it
  " for some reason powerline loses its colours when we do this in an autocmd
  " even though it doesn't if we just source it manually
  au BufWritePost .vimrc so ~/.vimrc | PowerlineReloadColorscheme
augroup END
